1. Learn & use tcpdump, netstat, ifconfig, nslookup, traceroute + capture ping/traceroute PDUs
Useful commands (Linux)
# show interfaces (modern systems: ip is preferred, but you asked ifconfig)
sudo ifconfig -a

# network connections and listening ports
netstat -tulnp       # show TCP/UDP listening and processes
ss -tunap            # ss is modern replacement

# DNS lookup
nslookup example.com
dig example.com

# path to destination
traceroute example.com
# or modern: tracepath example.com

# capture ICMP (ping) and UDP traceroute (often UDP or ICMP) using tcpdump
sudo tcpdump -i any icmp                # capture ping (ICMP)
sudo tcpdump -i any 'icmp or udp'       # capture ICMP or UDP packets

# save capture to file for later analysis in Wireshark/tshark
sudo tcpdump -i any -w capture.pcap icmp or udp

# show capture quickly with tshark (text)
tshark -r capture.pcap -Y icmp          # filter for ICMP in the pcap
tshark -r capture.pcap -Y "udp && ip.dst==1.2.3.4"


How to capture ping/traceroute PDUs

Start tcpdump (or Wireshark) on interface: sudo tcpdump -i eth0 -w lab1.pcap icmp or udp

In another terminal run ping <target> or traceroute <target>

Stop capture and open lab1.pcap in Wireshark or use tshark -r lab1.pcap to inspect fields.

2. HTTP web client using TCP sockets (Python, minimal)
# save as http_client.py
import socket

def download(host, path='/'):
    port = 80
    s = socket.socket()
    s.connect((host, port))
    req = f"GET {path} HTTP/1.0\r\nHost: {host}\r\n\r\n"
    s.send(req.encode())
    data = b''
    while True:
        chunk = s.recv(4096)
        if not chunk:
            break
        data += chunk
    s.close()
    return data.decode(errors='ignore')

if __name__ == "__main__":
    print(download('example.com', '/'))


Run: python3 http_client.py — prints the raw HTTP response.

3. Applications using TCP sockets
a) Echo server & client (Python)

Echo server:

# echo_server.py
import socket
s = socket.socket()
s.bind(('0.0.0.0', 9000))
s.listen(1)
print("Echo server on 9000")
conn, addr = s.accept()
print("Conn from", addr)
while True:
    data = conn.recv(1024)
    if not data:
        break
    conn.sendall(data)
conn.close()


Echo client:

# echo_client.py
import socket
s = socket.socket()
s.connect(('127.0.0.1', 9000))
s.sendall(b'hello\n')
print(s.recv(1024))
s.close()

b) Chat (very simple single-room)

Use same pattern: server accepts multiple clients and forwards messages. (If you want, I can give a short multi-client chat example next.)

c) File transfer (TCP) — simple send/receive

Server receive:

# file_recv.py
import socket
s = socket.socket(); s.bind(('0.0.0.0', 9001)); s.listen(1)
conn, _ = s.accept()
with open('received.bin', 'wb') as f:
    while True:
        chunk = conn.recv(4096)
        if not chunk: break
        f.write(chunk)
conn.close()


Client send:

# file_send.py
import socket
s = socket.socket(); s.connect(('127.0.0.1', 9001))
with open('bigfile.bin','rb') as f:
    while chunk := f.read(4096):
        s.sendall(chunk)
s.close()

4. Simulation of DNS using UDP sockets (simple authoritative server)

UDP DNS-like server (toy):

# dns_server.py
import socket
records = {'example.local':'192.168.1.100', 'server.local':'10.0.0.5'}
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind(('0.0.0.0', 53535))
print("Toy DNS server on 53535")
while True:
    data, addr = sock.recvfrom(512)
    name = data.decode().strip()
    ip = records.get(name, '0.0.0.0')
    sock.sendto(ip.encode(), addr)


Client:

# dns_client.py
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.sendto(b'example.local', ('127.0.0.1', 53535))
print(s.recv(512).decode())


This simulates request→response using UDP.

5. Simulate ARP / RARP protocols (toy) — using UDP messages to simulate broadcasts

ARP table simulator:

# arp_sim.py (run multiple instances or simulate logically)
# This is a logical simulation: uses UDP to broadcast request and answer.
import socket, threading
MY_IP = '10.0.0.2'
MY_MAC = 'aa:bb:cc:dd:ee:02'
BCAST_PORT = 37020

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
sock.bind(('', BCAST_PORT))

arp_table = {}

def listen():
    while True:
        data, addr = sock.recvfrom(1024)
        msg = data.decode()
        if msg.startswith('ARP_REQ'):    # ARP request: "ARP_REQ 10.0.0.3"
            _, ip = msg.split()
            if ip == MY_IP:
                sock.sendto(f"ARP_REP {MY_IP} {MY_MAC}".encode(), addr)
        elif msg.startswith('ARP_REP'):
            _, ip, mac = msg.split()
            arp_table[ip] = mac
            print("ARP table updated:", arp_table)

threading.Thread(target=listen, daemon=True).start()

# make a request for demonstration
import time
time.sleep(0.5)
sock.sendto(b'ARP_REQ 10.0.0.2', ('127.0.0.1', BCAST_PORT))
time.sleep(1)
print("Final ARP table:", arp_table)


This is a lab-level simulation using messages instead of raw Ethernet.

6. Study of Network simulator (NS) and Simulation of Congestion Control Algorithms

Running ns-2/ns-3 is involved. Below is a small Python AIMD (TCP-like) congestion-window simulator to demonstrate Additive Increase Multiplicative Decrease:

# aimd_sim.py
import random, matplotlib.pyplot as plt

def simulate(rounds=100, loss_prob=0.05):
    cwnd = 1.0
    history = []
    for r in range(rounds):
        # send one RTT: cwnd packets; loss occurs with probability loss_prob
        loss = random.random() < loss_prob
        if loss:
            cwnd *= 0.5  # multiplicative decrease
        else:
            cwnd += 1.0  # additive increase per RTT
        if cwnd < 1: cwnd = 1
        history.append(cwnd)
    return history

if __name__ == "__main__":
    hist = simulate(200, 0.08)
    plt.plot(hist)
    plt.xlabel("RTT")
    plt.ylabel("cwnd")
    plt.title("AIMD cwnd evolution")
    plt.show()


This demonstrates congestion window dynamics.

7. Study TCP/UDP performance using a simple test tool (Python)

Server (supports both TCP & UDP):

# perf_server.py
import socket, threading

def tcp_server():
    s = socket.socket(); s.bind(('0.0.0.0', 9002)); s.listen(1)
    conn, _ = s.accept()
    bytes_recv = 0
    while chunk := conn.recv(4096):
        bytes_recv += len(chunk)
    print("TCP received bytes:", bytes_recv)

def udp_server():
    u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    u.bind(('0.0.0.0', 9003))
    bytes_recv = 0
    try:
        while True:
            data, _ = u.recvfrom(65536)
            bytes_recv += len(data)
    except KeyboardInterrupt:
        print("UDP received bytes:", bytes_recv)

import threading
threading.Thread(target=tcp_server, daemon=True).start()
threading.Thread(target=udp_server, daemon=True).start()
input("Servers running. Ctrl+C in UDP terminal to stop.\n")


Client (send big chunk and measure time):

# perf_client_tcp.py
import socket, time
data = b'x'*1024*1024  # 1 MB
s = socket.socket(); s.connect(('127.0.0.1', 9002))
t0 = time.time()
s.sendall(data*5)  # send 5MB
s.close()
print("Elapsed:", time.time()-t0)


Do similar for UDP using sendto() and measure throughput.

8. Simulation of Distance Vector / Link State routing algorithms (small Python)
Distance Vector (Bellman-Ford style, iterative)
# distance_vector.py
INF = 10**9
graph = {
    'A': {'B':1, 'C':5},
    'B': {'A':1, 'C':2, 'D':4},
    'C': {'A':5, 'B':2, 'D':1},
    'D': {'B':4, 'C':1}
}

def distance_vector(nodes, graph):
    dist = {u: {v:(0 if u==v else INF) for v in nodes} for u in nodes}
    for u in nodes:
        for v,w in graph.get(u, {}).items():
            dist[u][v] = w
    changed = True
    while changed:
        changed = False
        for u in nodes:
            for v in nodes:
                for nbr,w in graph.get(u, {}).items():
                    if dist[u][v] > w + dist[nbr][v]:
                        dist[u][v] = w + dist[nbr][v]; changed=True
    return dist

print(distance_vector(list(graph.keys()), graph))

Link State (Dijkstra)
# link_state.py
import heapq
def dijkstra(src, graph):
    dist = {v:float('inf') for v in graph}; dist[src]=0
    pq = [(0, src)]
    while pq:
        d,u = heapq.heappop(pq)
        if d!=dist[u]: continue
        for v,w in graph[u].items():
            nd = d + w
            if nd < dist[v]:
                dist[v] = nd; heapq.heappush(pq, (nd,v))
    return dist

print(dijkstra('A', graph))

9. Performance evaluation of Routing protocols using a simulation tool (simple comparative script)

You can use the DV and LS functions above to measure convergence iterations or time for random link cost changes.

Example: compare iterations to converge after a link cost change (DV vs recompute Dijkstra):

# compare_convergence.py
from distance_vector import distance_vector
from link_state import dijkstra
# For DV, we can count while loops iterations (modify function to return count)
# For LS (link-state), recompute Dijkstra from each node and measure time
import time
# (left as exercise to instrument; if you want I can give full script)


If you want a ready experiment, I’ll extend with iteration counting and randomized link changes.

10. Simulation of error detection using CRC (Python)

Compute CRC-16-CCITT (simple example) and simulate error detection:

# crc16.py
def crc16_ccitt(data: bytes, poly=0x1021, init=0xffff):
    crc = init
    for b in data:
        crc ^= (b << 8)
        for _ in range(8):
            if crc & 0x8000:
                crc = ((crc << 1) & 0xffff) ^ poly
            else:
                crc = (crc << 1) & 0xffff
    return crc & 0xffff

if __name__ == "__main__":
    msg = b'hello world'
    c = crc16_ccitt(msg)
    print(hex(c))
    # simulate flip
    corrupted = b'hello worle'  # last char changed
    print("Corrupted detected?" , crc16_ccitt(corrupted) != c)
