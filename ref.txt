2) Lexical Analyzer using C (manual scanner)

File: lexical_c.c
A tiny C program that reads input and prints tokens (identifiers, numbers, operators).

// lexical_c.c - simple hand-written lexical analyser in C
#include <stdio.h>
#include <ctype.h>

int main(){
    int c;
    while((c=getchar())!=EOF){
        if(isspace(c)) continue;
        if(isalpha(c)){
            putchar('[');
            do { putchar(c); c=getchar(); } while(isalnum(c));
            putchar(']'); ungetc(c, stdin);
            printf(" : ID\n");
        } else if(isdigit(c)){
            putchar('[');
            do { putchar(c); c=getchar(); } while(isdigit(c));
            putchar(']'); ungetc(c, stdin);
            printf(" : NUM\n");
        } else {
            printf("SYMBOL: %c\n", c);
        }
    }
    return 0;
}


Build & run

gcc lexical_c.c -o lexical_c
echo "a = 123 + b" | ./lexical_c


Example output

[a] : ID
[=] : NUM? (actually symbol handling will show)
...


(This is intentionally minimal — use it as a template for lab demonstration.)

3) Lex Tool (flex) lexical analyzer — minimal

File: tac.l

%{
#include <stdio.h>
%}
%%
[ \t]+           ;            /* ignore spaces */
[a-zA-Z_][a-zA-Z0-9_]*  { printf("ID(%s)\n", yytext); }
[0-9]+           { printf("NUM(%s)\n", yytext); }
"="              { printf("ASSIGN\n"); }
"+"              { printf("PLUS\n"); }
"-"              { printf("MINUS\n"); }
"*"              { printf("MUL\n"); }
"/"              { printf("DIV\n"); }
\n               { /* newline */ }
.                { /* ignore */ }
%%
int main(){ yylex(); return 0; }


Build & run

flex tac.l
gcc lex.yy.c -o tac_lex -lfl
echo "t1 = a + 10" | ./tac_lex


Output

ID(t1)
ASSIGN
ID(a)
PLUS
NUM(10)

4) Calculator using Lex + Yacc (flex + bison) — minimal

This evaluates integer expressions with + - * / and parentheses.

File: calc.l (flex)

%{
#include "calc.tab.h"
%}
%%
[ \t]+      ;
[0-9]+      { yylval = atoi(yytext); return NUM; }
"("         return '(';
")"         return ')';
"+"         return '+';
"-"         return '-';
"*"         return '*';
"/"         return '/';
\n          return 0;
.           ;
%%
int yywrap(){ return 1; }


File: calc.y (bison)

%{
#include <stdio.h>
int yylex();
void yyerror(const char *s){ fprintf(stderr,"Err: %s\n",s); }
%}
%token NUM
%left '+' '-'
%left '*' '/'
%%
input:
    expr    { printf("%d\n", $1); }
  ;
expr:
    NUM     { $$ = $1; }
  | expr '+' expr { $$ = $1 + $3; }
  | expr '-' expr { $$ = $1 - $3; }
  | expr '*' expr { $$ = $1 * $3; }
  | expr '/' expr { $$ = $1 / $3; }
  | '(' expr ')'  { $$ = $2; }
  ;
%%
int main(){ printf("Enter expression:\n"); yyparse(); return 0; }


Build & run

bison -d calc.y      # produces calc.tab.c calc.tab.h
flex calc.l          # produces lex.yy.c
gcc calc.tab.c lex.yy.c -o calc -lfl
echo "3 + 4 * (2 + 1)" | ./calc


Output

Enter expression:
15

5) Generate Three Address Code (TAC) using Lex + Yacc — minimal

This example converts arithmetic expressions to simple TAC instructions (temp vars).

File: tacgen.l

%{
#include "tacgen.tab.h"
%}
%%
[ \t]+      ;
[0-9]+      { yylval.s = strdup(yytext); return NUM; }
[a-zA-Z_][a-zA-Z0-9_]* { yylval.s = strdup(yytext); return ID; }
"="         return '=';
"+"         return '+';
"-"         return '-';
"*"         return '*';
"/"         return '/';
\n          return 0;
.           ;
%%
int yywrap(){return 1;}


File: tacgen.y

%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int tempid = 0;
char *newtemp(){ char buf[16]; sprintf(buf,"t%d",++tempid); return strdup(buf); }
%}
%union { char *s; }
%token <s> ID NUM
%left '+' '-'
%left '*' '/'
%%
input:
    stmt
  ;
stmt:
    ID '=' expr { printf("%s = %s\n", $1, $3); }
  ;
expr:
    NUM    { $$ = $1; }
  | ID     { $$ = $1; }
  | expr '+' expr {
      char *t = newtemp();
      printf("%s = %s + %s\n", t, $1, $3);
      $$ = t;
    }
  | expr '-' expr {
      char *t = newtemp();
      printf("%s = %s - %s\n", t, $1, $3);
      $$ = t;
    }
  | expr '*' expr {
      char *t = newtemp();
      printf("%s = %s * %s\n", t, $1, $3);
      $$ = t;
    }
  | expr '/' expr {
      char *t = newtemp();
      printf("%s = %s / %s\n", t, $1, $3);
      $$ = t;
    }
  ;
%%
int main(){ yyparse(); return 0; }
void yyerror(const char *s){ fprintf(stderr,"Err: %s\n",s); }


Build & run

bison -d tacgen.y
flex tacgen.l
gcc tacgen.tab.c lex.yy.c -o tacgen -lfl
echo "z = a + b * 2" | ./tacgen


Output (example)

t1 = b * 2
t2 = a + t1
z = t2

6) Implement Type Checking using Lex + Yacc — minimal

Simple type checker: declarations and expressions for int only (detects undeclared var & type mismatch).

File: typecheck.l

%{
#include "typecheck.tab.h"
%}
%%
"int"       { return INT; }
[a-zA-Z_][a-zA-Z0-9_]* { yylval.s = strdup(yytext); return ID; }
[0-9]+      { yylval.s = strdup(yytext); return NUM; }
[ \t]+      ; 
"="         return '='; 
";"         return ';';
"+"         return '+';
"\n"        return 0;
.           ;
%%
int yywrap(){return 1;}


File: typecheck.y

%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef struct Sym{ char *name; char *type; struct Sym*next;} Sym;
Sym *sym=0;
void add_sym(char*name,char*type){ Sym*n=malloc(sizeof* n); n->name=strdup(name); n->type=strdup(type); n->next=sym; sym=n;}
char* find_sym(char*name){ for(Sym*p=sym;p;p=p->next) if(strcmp(p->name,name)==0) return p->type; return NULL; }
%}
%union { char *s; }
%token <s> ID NUM
%token INT
%%
input:
    decls stmts
  ;
decls:
    decls decl
  | /* empty */
  ;
decl:
    INT ID ';' { add_sym($2,"int"); printf("decl %s:int\n",$2); }
  ;
stmts:
    stmts stmt
  | /* empty */
  ;
stmt:
    ID '=' expr ';' {
        char *t = find_sym($1);
        if(!t) printf("Error: %s not declared\n",$1);
        else {
            if(strcmp(t,"int")!=0) printf("Type error assign to %s\n",$1);
            else printf("assign %s = %s\n",$1,$3);
        }
    }
  ;
expr:
    NUM { $$ = $1; }
  | ID { if(!find_sym($1)) printf("Error: %s not declared\n",$1); $$ = $1; }
  ;
%%
int main(){ yyparse(); return 0; }
void yyerror(const char *s){ fprintf(stderr,"Err: %s\n",s); }


Build & run

bison -d typecheck.y
flex typecheck.l
gcc typecheck.tab.c lex.yy.c -o typecheck -lfl
printf "int a;\na = 5;\nb = 3;\n" | ./typecheck


Output

decl a:int
assign a = 5
Error: b not declared

7) Simple Code Optimization Technique (constant folding for TAC) — minimal

Input: TAC lines; output: optimized TAC with constant folding.

File: optimize.c

// optimize.c - reads simple TAC "t = x op y" or "x = CONST", folds constants
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

int isnum(const char*s){ if(!s) return 0; if(*s=='-'||*s=='+') s++; while(*s){ if(!isdigit(*s)) return 0; s++; } return 1; }

int main(){
    char a[128], eq[8], b[128], op[8], c[128];
    while(scanf("%s", a)==1){
        if(strcmp(a,"")==0) break;
        if(scanf("%s", eq)!=1) break; // =
        if(scanf("%s", b)!=1) break;
        if(isnum(b) && (scanf("%s", op)==1) && isnum((scanf("%s", c), c) , 0)) {
            ; // fallback (rare)
        }
        // try to detect patterns "x = NUM" or "t = x + y"
        if(strcmp(eq,"=")!=0) continue;
        // peek rest of line
        int ch = getchar();
        if(ch=='\n' || ch==EOF){
            // simple assignment x = y
            printf("%s = %s\n", a, b);
        } else {
            // read op and c
            ungetc(ch, stdin);
            if(scanf("%s %s", op, c)==2){
                if(isnum(b) && isnum(c)){
                    long v1 = atol(b), v2 = atol(c);
                    long res=0;
                    if(strcmp(op,"+")==0) res=v1+v2;
                    else if(strcmp(op,"-")==0) res=v1-v2;
                    else if(strcmp(op,"*")==0) res=v1*v2;
                    else if(strcmp(op,"/")==0 && v2!=0) res=v1/v2;
                    printf("%s = %ld\t; folded\n", a, res);
                } else {
                    printf("%s = %s %s %s\n", a, b, op, c);
                }
            }
        }
    }
    return 0;
}


Build & run

gcc optimize.c -o optimize
printf "t1 = 2 + 3\nt2 = a + b\nx = 5\n" | ./optimize


Output

t1 = 5    ; folded
t2 = a + b
x = 5

8) Back-end: TAC → 8086 assembly (Lex + Yacc) — minimal

(We already covered a minimal version earlier. Here’s a slightly improved, ready-to-run pair.)

File: tac2asm.l

%{
#include "tac2asm.tab.h"
%}
%%
[ \t]+      ;
[0-9]+      { yylval.s = strdup(yytext); return NUM; }
[a-zA-Z_][a-zA-Z0-9_]* { yylval.s = strdup(yytext); return ID; }
"="         return ASSIGN;
"+"         return PLUS;
"-"         return MINUS;
"*"         return MUL;
"/"         return DIV;
\n          return 0;
.           ;
%%
int yywrap(){return 1;}


File: tac2asm.y

%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
void emit(const char*s){ printf("%s\n", s); }
%}
%union { char *s; }
%token <s> ID NUM
%token ASSIGN PLUS MINUS MUL DIV
%%
input:
    lines
  ;
lines:
    lines line
  | /* empty */
  ;
line:
    ID ASSIGN ID PLUS ID { printf("MOV AX, [%s]\nADD AX, [%s]\nMOV [%s], AX\n", $3, $5, $1); }
  | ID ASSIGN ID MINUS ID { printf("MOV AX, [%s]\nSUB AX, [%s]\nMOV [%s], AX\n", $3, $5, $1); }
  | ID ASSIGN ID MUL ID { printf("MOV AX, [%s]\nIMUL AX, [%s]\nMOV [%s], AX\n", $3, $5, $1); }
  | ID ASSIGN ID DIV ID { printf("MOV AX, [%s]\nIDIV [%s]\nMOV [%s], AX\n", $3, $5, $1); }
  | ID ASSIGN ID { printf("MOV AX, [%s]\nMOV [%s], AX\n", $3, $1); }
  ;
%%
int main(){ printf("; 8086 assembly\n"); yyparse(); return 0; }
void yyerror(const char*s){ fprintf(stderr,"Err: %s\n",s); }


Build & run

bison -d tac2asm.y
flex tac2asm.l
gcc tac2asm.tab.c lex.yy.c -o tac2asm -lfl
printf "t1 = a + b\nt2 = t1 * c\nresult = t2\n" | ./tac2asm


Output

; 8086 assembly
MOV AX, [a]
ADD AX, [b]
MOV [t1], AX
MOV AX, [t1]
IMUL AX, [c]
MOV [t2], AX
MOV AX, [t2]
MOV [result], AX

9) Program to recognize a valid arithmetic expression (+ - * /) — Lex + Yacc

(This is similar to calculator above, but specifically recognizing validity.)

Files: use calc.l and calc.y from the Calculator example (Section 4). That parser accepts expressions with + - * / and parentheses. To test validity just run and check if parse succeeds.

10) Program to recognize a valid variable (starts with a letter then letters/digits) — Lex only

File: var.l

%{
#include <stdio.h>
%}
%%
^[ \t]*[a-zA-Z][a-zA-Z0-9]*[ \t]*$   { printf("Valid identifier: %s\n", yytext); }
.*                                     { printf("Invalid: %s\n", yytext); }
%%
int main(){ yylex(); return 0; }


Run

flex var.l
gcc lex.yy.c -o var -lfl
echo "var1" | ./var
echo "1var" | ./var

11) Program to recognize control-structure syntax (for, while, if-else, switch) — minimal Yacc grammar

This is a simplified grammar to validate the high-level syntax (not full C).

File: ctl.l

%{
#include "ctl.tab.h"
%}
%%
"for"      return FOR;
"while"    return WHILE;
"if"       return IF;
"else"     return ELSE;
"switch"   return SWITCH;
"case"     return CASE;
[ \t\n]+   ;
.          { return *yytext; }
%%
int yywrap(){return 1;}


File: ctl.y

%{
#include <stdio.h>
void yyerror(const char*s){ fprintf(stderr,"Err: %s\n",s); }
%}
%token FOR WHILE IF ELSE SWITCH CASE
%%
program:
    stmt_list
  ;
stmt_list:
    stmt_list stmt
  | /* empty */
  ;
stmt:
    FOR '(' ')' stmt
  | WHILE '(' ')' stmt
  | IF '(' ')' stmt ELSE stmt
  | IF '(' ')' stmt
  | SWITCH '(' ')' '{' case_list '}'
  | '{' stmt_list '}'
  | ';'
  ;
case_list:
    case_list CASE ':' stmt_list
  | /* empty */
  ;
%%
int main(){ yyparse(); printf("Parsing finished\n"); return 0;}


Build & run

bison -d ctl.y
flex ctl.l
gcc ctl.tab.c lex.yy.c -o ctl -lfl
echo "if() { ; } else { ; }" | ./ctl


Output

Parsing finished

#include <stdio.h>
#include <string.h>

#define SIZE 20

struct Symbol {
    char name[20];
    char type[10];
    int address;
};

struct Symbol table[SIZE];
int count = 0;

void insert() {
    if (count >= SIZE) {
        printf("Symbol Table Full!\n");
        return;
    }
    printf("Enter symbol name: ");
    scanf("%s", table[count].name);
    printf("Enter type: ");
    scanf("%s", table[count].type);
    table[count].address = count + 100;  // Just a simple address
    count++;
    printf("Symbol inserted!\n\n");
}

void display() {
    printf("\n---------------- SYMBOL TABLE ----------------\n");
    printf("%-10s %-10s %-10s\n", "Name", "Type", "Address");
    printf("----------------------------------------------\n");
    for (int i = 0; i < count; i++)
        printf("%-10s %-10s %-10d\n", table[i].name, table[i].type, table[i].address);
    printf("----------------------------------------------\n\n");
}

void search() {
    char name[20];
    printf("Enter symbol name to search: ");
    scanf("%s", name);
    for (int i = 0; i < count; i++) {
        if (strcmp(table[i].name, name) == 0) {
            printf("Symbol found! Type: %s, Address: %d\n\n", table[i].type, table[i].address);
            return;
        }
    }
    printf("Symbol not found!\n\n");
}

int main() {
    int choice;
    while (1) {
        printf("1. Insert\n2. Display\n3. Search\n4. Exit\nEnter choice: ");
        scanf("%d", &choice);
        switch (choice) {
            case 1: insert(); break;
            case 2: display(); break;
            case 3: search(); break;
            case 4: return 0;
            default: printf("Invalid choice!\n");
        }
    }
}

